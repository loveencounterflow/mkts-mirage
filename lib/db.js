// Generated by CoffeeScript 2.4.1
(function() {
  'use strict';
  var $, $async, CND, ICQL, PATH, PD, abspath, assign, badge, boolean_as_int, debug, echo, help, info, inspect, join_path, jr, rpr, select, urge, warn, whisper, xrpr, xrpr2;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MKTS-MIRAGE/DB';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  PATH = require('path');

  // FS                        = require 'fs'
  PD = require('pipedreams');

  ({$, $async, select} = PD);

  ({assign, jr} = CND);

  //...........................................................................................................
  join_path = function(...P) {
    return PATH.resolve(PATH.join(...P));
  };

  boolean_as_int = function(x) {
    if (x) {
      return 1;
    } else {
      return 0;
    }
  };

  ({inspect} = require('util'));

  xrpr = function(x) {
    return inspect(x, {
      colors: true,
      breakLength: 2e308,
      maxArrayLength: 2e308,
      depth: 2e308
    });
  };

  xrpr2 = function(x) {
    return inspect(x, {
      colors: true,
      breakLength: 80,
      maxArrayLength: 2e308,
      depth: 2e308
    });
  };

  //...........................................................................................................
  ICQL = require('icql');

  // INTERTYPE                 = require './types'
  ({assign, abspath} = require('./helpers'));

  //-----------------------------------------------------------------------------------------------------------
  this.get_icql_settings = function(db_path = null) {
    var R;
    /* TAINT path within node_modules might differ */
    /* TAINT extensions should conceivably be configured in `*.icql` file or similar */
    // R.db_path   = join_path __dirname, '../../db/data.db'
    R = {};
    R.connector = require('better-sqlite3');
    R.db_path = db_path != null ? db_path : abspath('./db/mkts.db');
    R.icql_path = abspath('./db/mkts.icql');
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_db = function(settings) {
    var clear_count, clear_db, db, ref, ref1;
    db = ICQL.bind(this.get_icql_settings((ref = settings != null ? settings.db_path : void 0) != null ? ref : null));
    clear_db = (ref1 = settings != null ? settings.clear : void 0) != null ? ref1 : false;
    this.load_extensions(db);
    this.set_pragmas(db);
    //.........................................................................................................
    if (clear_db) {
      clear_count = db.$.clear();
      info(`deleted ${clear_count} objects`);
    }
    //.........................................................................................................
    this.create_db_functions(db);
    //.........................................................................................................
    return db;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.set_pragmas = function(db) {
    db.$.pragma('foreign_keys = on');
    db.$.pragma('synchronous = off');
    /* see https://sqlite.org/pragma.html#pragma_synchronous */    db.$.pragma('journal_mode = WAL');
//.........................................................................................................
/* see https://github.com/JoshuaWise/better-sqlite3/issues/125 */    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.load_extensions = function(db) {
    var extensions_path;
    warn("skipping sqlite extensions");
    return null;
    extensions_path = abspath('./sqlite-for-mingkwai-ime/extensions');
    debug('µ39982', "extensions_path", extensions_path);
    db.$.load(join_path(extensions_path, 'spellfix.so'));
    db.$.load(join_path(extensions_path, 'csv.so'));
    db.$.load(join_path(extensions_path, 'regexp.so'));
    db.$.load(join_path(extensions_path, 'series.so'));
    db.$.load(join_path(extensions_path, 'nextchar.so'));
    // db.$.load join_path extensions_path, 'stmt.so'
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.create_db_functions = function(db) {
    // db.$.function 'add_spellfix_confusable', ( a, b ) ->
    // db.$.function 'spellfix1_phonehash', ( x ) ->
    //   debug '23363', x
    //   return x.toUpperCase()

    //---------------------------------------------------------------------------------------------------------
    db.$.function('echo', {
      deterministic: false,
      varargs: true
    }, function(...P) {
      /* Output text to command line. */
      /* TAINT consider to use logging method to output to app console. */
      urge(CND.grey('DB'), ...P);
      return null;
    });
    //---------------------------------------------------------------------------------------------------------
    db.$.function('e', {
      deterministic: false,
      varargs: false
    }, function(x) {
      /* Output text to command line, but returns single input value so can be used within an expression. */
      urge(CND.grey('DB'), rpr(x));
      return x;
    });
    //---------------------------------------------------------------------------------------------------------
    db.$.function('e', {
      deterministic: false,
      varargs: false
    }, function(mark, x) {
      /* Output text to command line, but returns single input value so can be used within an expression. */
      urge(CND.grey(`DB ${mark}`), rpr(x));
      return x;
    });
    //---------------------------------------------------------------------------------------------------------
    db.$.function('contains_word', {
      deterministic: true,
      varargs: false
    }, function(text, probe) {
      if (((' ' + text + ' ').indexOf(' ' + probe + ' ')) > -1) {
        return 1;
      } else {
        return 0;
      }
    });
    //---------------------------------------------------------------------------------------------------------
    db.$.function('get_words', {
      deterministic: true,
      varargs: false
    }, function(text) {
      var word;
      /* Given a text, return a JSON array with words (whitespace-separated non-empty substrings). */
      return JSON.stringify((function() {
        var i, len, ref, results;
        ref = text.split(/\s+/);
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          word = ref[i];
          if (word !== '') {
            results.push(word);
          }
        }
        return results;
      })());
    });
    // #---------------------------------------------------------------------------------------------------------
    // db.$.function 'vnr_encode_textual', { deterministic: true, varargs: false }, ( vnr ) ->
    //   ( ( "#{idx}".padStart 6, '0' ) for idx in ( JSON.parse vnr ) ).join '-'

    //---------------------------------------------------------------------------------------------------------
    db.$.function('vnr_encode', {
      deterministic: true,
      varargs: false
    }, function(vnr) {
      var error;
      try {
        return Uint32Array.from(JSON.parse(vnr));
      } catch (error1) {
        error = error1;
        warn(`µ33211 when trying to convert ${xrpr2(vnr)}`);
        warn("µ33211 to a typed array, an error occurred:");
        warn(`µ33211 ${error.message}`);
        throw error;
      }
    });
    // #---------------------------------------------------------------------------------------------------------
    // db.$.function 'get_nth_word', { deterministic: true, varargs: false }, ( text, nr ) ->
    //   ### NB SQLite has no string aggregation, no string splitting, and in general does not implement
    //   table-returning user-defined functions (except in C, see the `prefixes` extension). Also, you can't
    //   modify tables from within a UDF because the connection is of course busy executing the UDF.
    //   As a consequence, it is well-nigh impossible to split strings to rows in a decent manner. You could
    //   probably write a 12-liner with a recursive CTE each time you want to split a string. Unnecessary to
    //   mention that SQLite does not support putting *that* thing into a UDF (because those can't return
    //   anything except a single atomic value).

    //   **Update** Turns out the `json1` extension can help out; see the `get_words()` UDF. ###
    //   ### TAINT to be deprecated in favor of `get_words()` ###
    //   parts = text.split /\s+/
    //   return parts[ nr - 1 ] ? null

    //---------------------------------------------------------------------------------------------------------
    return null;
  };

}).call(this);

//# sourceMappingURL=db.js.map
