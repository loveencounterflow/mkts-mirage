// Generated by CoffeeScript 2.4.1
(function() {
  'use strict';
  var $, $async, $watch, CND, FS, ICE, MIRAGE, PATH, PD, abspath, assign, badge, debug, declare, do_validate, echo, first, help, info, isa, jr, last, relpath, rpr, select, size_of, stamp, testing, type_of, types, urge, validate, warn, whisper;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MKTS-MIRAGE/EXPERIMENTS/EXPANDING-LINES';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  FS = require('fs');

  PATH = require('path');

  PD = require('pipedreams');

  ({$, $watch, $async, select, stamp} = PD);

  ({assign, jr} = CND);

  first = Symbol('first');

  last = Symbol('last');

  types = require('../types');

  //...........................................................................................................
  ({isa, validate, declare, size_of, type_of} = types);

  //...........................................................................................................
  ({assign, abspath, relpath} = require('../helpers'));

  //...........................................................................................................
  require('../exception-handler');

  ICE = require('icepick');

  MIRAGE = require('../..');

  do_validate = true;

  /*

  TAINT consider to backport these flags to PipeDreams:

  * [ ] `$dirty`—whether any property of a datom has beem modified;
  * [ ] `$fresh`—whether a datom originated from within the stream, not from the source;
  * [X] `$stamped`—whether a datom has been processed.

   */
  //-----------------------------------------------------------------------------------------------------------
  this.new_datom = function(...P) {
    var R;
    R = PD.new_datom(...P);
    if (((!R.vnr_txt) != null) && (R.$vnr != null)) {
      R.vnr_txt = jr(R.$vnr);
    }
    R.$fresh = true;
    return ICE.freeze(R);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.stamp = function(d) {
    /* NOTE we could use `icepick`'s 'copy-on-write'/structural sharing features here but that is probably
    of little effect given how small our objects are; we therefore use the much simpler 'copy-on-thaw' and
    re-freezing while enjoying the simplicity and clarity of intermittent (and contained) old-fashioned data
    mutation. */
    var R;
    R = ICE.thaw(d);
    R.$stamped = true;
    R.$dirty = true;
    return ICE.freeze(R);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_vnr_level = function(S, vnr) {
    var R;
    /* Given a `mirage` instance and a vectorial line number `vnr`, return a copy of `vnr`, call it
    `vnr0`, which has an index of `0` appended, thus representing the pre-first `vnr` for a level of lines
    derived from the one that the original `vnr` pointed to. */
    validate.nonempty_list(vnr);
    R = assign([], vnr);
    R.push(0);
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.advance_vnr = function(S, vnr) {
    var R;
    /* Given a `mirage` instance and a vectorial line number `vnr`, return a copy of `vnr`, call it
    `vnr0`, which has its last index incremented by `1`, thus representing the vectorial line number of the
    next line in the same level that is derived from the same line as its predecessor. */
    validate.nonempty_list(vnr);
    R = assign([], vnr);
    R[vnr.length - 1] += +1;
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$split_words = function(S) {
    return $((d, send) => {
      var i, len, nxt_vnr, prv_vnr, ref, text, word;
      if (!select(d, '^mktscript')) {
        return send(d);
      }
      //.........................................................................................................
      send(this.stamp(d));
      text = d.text;
      prv_vnr = d.$vnr;
      nxt_vnr = this.new_vnr_level(S, prv_vnr);
      ref = text.split(/\s+/);
      //.........................................................................................................
      // unless isa.blank_text row.value
      for (i = 0, len = ref.length; i < len; i++) {
        word = ref[i];
        if (word === '') {
          continue;
        }
        nxt_vnr = this.advance_vnr(S, nxt_vnr);
        send(this.new_datom('^word', {
          text: word,
          $vnr: nxt_vnr
        }));
      }
      //.........................................................................................................
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.datom_from_row = function(S, row) {
    var $vnr, R, vnr_txt;
    /* TAINT how to convert vnr in ICQL? */
    debug('µ22299', row);
    vnr_txt = row.vnr_txt;
    $vnr = JSON.parse(vnr_txt);
    R = ICE.freeze(PD.new_datom(row.key, {
      text: row.value,
      $vnr,
      vnr_txt
    }));
    if (row.stamped) {
      R.$stamped = true;
    }
    debug('µ22299', R);
    debug('µ22299', PD.new_datom('^foo', 42));
    debug('µ22299', PD.new_datom('^foo', {
      x: 42
    }));
    debug('µ22299', isa.object({
      x: 42
    }));
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.row_from_datom = function(S, d) {
    /* TAINT how to convert booleans in ICQL? */
    var R, stamped;
    stamped = d.$stamped ? 1 : 0;
    R = ICE.freeze({
      key: d.key,
      vnr_txt: d.vnr_txt,
      value: d.text,
      stamped
    });
    if (do_validate) {
      validate.mirage_main_row(R);
    }
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.feed_source = function(S, source, limit = 2e308) {
    var dbr, nr, ref, row;
    dbr = S.mirage.db;
    nr = 0;
    ref = dbr.read_unstamped_lines();
    //.........................................................................................................
    for (row of ref) {
      nr += +1;
      if (nr > limit) {
        break;
      }
      source.send(this.datom_from_row(S, row));
    }
    //.........................................................................................................
    source.end();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$feed_db = function(S) {
    /* TAINT stopgap measure; should be implemented in ICQL */
    var db2;
    db2 = (MIRAGE.new_settings(S.mirage)).db;
    return $watch((d) => {
      /* TAINT how to convert vnr in ICQL? */
      var error, row;
      row = this.row_from_datom(S, d);
      try {
        /* TAINT consider to use upsert instead https://www.sqlite.org/lang_UPSERT.html */
        if (d.$fresh) {
          db2.insert(row);
        } else if (d.$dirty) {
          db2.update(row);
        }
      } catch (error1) {
        error = error1;
        warn(`µ12133 when trying to insert or update row ${jr(row)}`);
        warn("µ12133 an error occurred:");
        warn(`µ12133 ${error.message}`);
        throw error;
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this._$show = function(S) {
    return $watch((d) => {
      var color;
      if (d.$stamped) {
        color = CND.grey;
      } else {
        switch (d.key) {
          case '^word':
            color = CND.gold;
            break;
          default:
            color = CND.white;
        }
      }
      return info(color(jr(d)));
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this._$on_finish = function(S) {
    var dbr;
    dbr = S.mirage.db;
    //.........................................................................................................
    return $watch({last}, (d) => {
      var color, key, ref, ref1, row, vnr;
      if (d !== last) {
        return null;
      }
      ref = dbr.read_lines();
      //.......................................................................................................
      for (row of ref) {
        color = row.stamped ? CND.grey : CND.green;
        key = row.key.padEnd(12);
        vnr = row.vnr_txt.padEnd(12);
        info(color(`${vnr} ${(row.stamped ? 'S' : ' ')} ${key} ${rpr(row.value.slice(0, 41))}`));
      }
      ref1 = dbr.get_stats();
      //.......................................................................................................
      for (row of ref1) {
        info(`${row.key}: ${row.count}`);
      }
      //.......................................................................................................
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.translate_document = function(me) {
    return new Promise((resolve, reject) => {
      var S, limit, pipeline, source;
      /* TAINT add suitable types */
      validate.object(me);
      S = {
        mirage: me
      };
      source = PD.new_push_source();
      limit = 2e308;
      //.........................................................................................................
      pipeline = [];
      pipeline.push(source);
      pipeline.push(PD.$show());
      pipeline.push(this.$split_words(S));
      pipeline.push(this.$feed_db(S));
      // pipeline.push @_$show()
      pipeline.push(this._$on_finish(S));
      pipeline.push(PD.$drain(() => {
        return resolve();
      }));
      //.........................................................................................................
      PD.pull(...pipeline);
      this.feed_source(S, source, limit);
      return null;
    });
  };

  //###########################################################################################################
  if (module.parent == null) {
    testing = true;
    (async() => {
      var mirage;
      //.......................................................................................................
      mirage = MIRAGE.new_settings('../README.md');
      await MIRAGE.acquire(mirage);
      await this.translate_document(mirage);
      return help('ok');
    })();
  }

}).call(this);

//# sourceMappingURL=demo-expanding-lines.js.map
